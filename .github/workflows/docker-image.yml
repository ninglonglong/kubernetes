# .github/workflows/build-and-push-to-acr.yml

name: Build K8s Changed Images and Push to ACR

on:
  # 允许手动触发，这时会构建所有组件
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag (e.g., dev, latest, or a version number)'
        required: true
        default: 'latest'
  # 当有代码推送到 master 分支时自动触发
  push:
    branches:
      - 'master' # 您可以修改为您进行开发的分支名

env:
  # 镜像仓库信息，从 Secrets 读取
  ALIYUN_REGISTRY: ${{ secrets.ALIYUN_REGISTRY }}
  ALIYUN_NAME_SPACE: ${{ secrets.ALIYUN_NAME_SPACE }}
  ALIYUN_REGISTRY_USER: ${{ secrets.ALIYUN_REGISTRY_USER }}
  ALIYUN_REGISTRY_PASSWORD: ${{ secrets.ALIYUN_REGISTRY_PASSWORD }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    # 这一步很关键，用于在步骤之间传递输出变量
    outputs:
      image_tag: ${{ steps.image_tag.outputs.IMAGE_TAG }}
      build-apiserver: ${{ steps.detect-changes.outputs.build-apiserver }}
      build-controller-manager: ${{ steps.detect-changes.outputs.build-controller-manager }}
      build-scheduler: ${{ steps.detect-changes.outputs.build-scheduler }}
      build-proxy: ${{ steps.detect-changes.outputs.build-proxy }}

    steps:
      - name: Checkout Kubernetes source code
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0 # 必须获取完整历史，以便 git diff
          fetch-tags: true

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Alibaba Cloud Container Registry (ACR)
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ALIYUN_REGISTRY }}
          username: ${{ env.ALIYUN_REGISTRY_USER }}
          password: ${{ env.ALIYUN_REGISTRY_PASSWORD }}

      - name: Determine Image Tag
        id: image_tag
        run: |
          # 手动触发使用输入，自动触发使用 commit SHA 前7位
          TAG=${{ github.event.inputs.image_tag || github.sha }}
          SHORT_TAG=${TAG::7}
          echo "IMAGE_TAG=${SHORT_TAG}" >> $GITHUB_OUTPUT
          echo "Final image tag will be: ${SHORT_TAG}"

      # ------------------------------------------------------------------
      # 核心步骤：变更检测
      # ------------------------------------------------------------------
      - name: Detect changed components
        id: detect-changes
        run: |
          # 定义每个组件的源码路径
          declare -A COMPONENT_PATHS
          COMPONENT_PATHS["apiserver"]="cmd/kube-apiserver/"
          COMPONENT_PATHS["controller-manager"]="cmd/kube-controller-manager/"
          COMPONENT_PATHS["scheduler"]="cmd/kube-scheduler/"
          COMPONENT_PATHS["proxy"]="cmd/kube-proxy/"

          # 定义可能影响所有组件的公共路径
          COMMON_PATHS="pkg/ staging/ vendor/ go.mod go.sum build/"
          
          # 默认所有组件都不需要构建
          BUILD_ALL="false"
          BUILD_APISERVER="false"
          BUILD_CONTROLLER_MANAGER="false"
          BUILD_SCHEDULER="false"
          BUILD_PROXY="false"

          # 如果是手动触发 (workflow_dispatch)，则构建所有组件
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Manual trigger detected. Building all components."
            BUILD_ALL="true"
          else
            # 自动触发，则进行变更检测
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
            echo "Changed files:"
            echo "$CHANGED_FILES"

            for path in $COMMON_PATHS; do
              if echo "$CHANGED_FILES" | grep -q "^$path"; then
                echo "Change detected in common path '$path'. Building all components."
                BUILD_ALL="true"
                break
              fi
            done
          fi

          if [ "$BUILD_ALL" == "true" ]; then
            BUILD_APISERVER="true"
            BUILD_CONTROLLER_MANAGER="true"
            BUILD_SCHEDULER="true"
            BUILD_PROXY="true"
          else
            # 仅检查特定组件的变更
            if echo "$CHANGED_FILES" | grep -q "^${COMPONENT_PATHS['apiserver']}"; then echo "Change detected in kube-apiserver."; BUILD_APISERVER="true"; fi
            if echo "$CHANGED_FILES" | grep -q "^${COMPONENT_PATHS['controller-manager']}"; then echo "Change detected in kube-controller-manager."; BUILD_CONTROLLER_MANAGER="true"; fi
            if echo "$CHANGED_FILES" | grep -q "^${COMPONENT_PATHS['scheduler']}"; then echo "Change detected in kube-scheduler."; BUILD_SCHEDULER="true"; fi
            if echo "$CHANGED_FILES" | grep -q "^${COMPONENT_PATHS['proxy']}"; then echo "Change detected in kube-proxy."; BUILD_PROXY="true"; fi
          fi

          # 输出结果，供后续作业或步骤使用
          echo "build-apiserver=${BUILD_APISERVER}" >> $GITHUB_OUTPUT
          echo "build-controller-manager=${BUILD_CONTROLLER_MANAGER}" >> $GITHUB_OUTPUT
          echo "build-scheduler=${BUILD_SCHEDULER}" >> $GITHUB_OUTPUT
          echo "build-proxy=${BUILD_PROXY}" >> $GITHUB_OUTPUT

  # ------------------------------------------------------------------
  # 新增一个作业，用于实际的构建和推送
  # 这样可以清晰地分离“检测”和“执行”
  # ------------------------------------------------------------------
  build-and-push-components:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: >
      needs.build-and-push.outputs.build-apiserver == 'true' ||
      needs.build-and-push.outputs.build-controller-manager == 'true' ||
      needs.build-and-push.outputs.build-scheduler == 'true' ||
      needs.build-and-push.outputs.build-proxy == 'true'
      
    env:
      KUBE_BUILD_PLATFORMS: linux/amd64
      KUBE_DOCKER_REGISTRY: ${{ secrets.ALIYUN_REGISTRY }}/${{ secrets.ALIYUN_NAME_SPACE }}
      KUBE_DOCKER_IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
      KUBE_FASTBUILD: true

    steps:
      - name: Checkout Kubernetes source code
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0
          fetch-tags: true

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Log in to Alibaba Cloud Container Registry (ACR)
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ALIYUN_REGISTRY }}
          username: ${{ secrets.ALIYUN_REGISTRY_USER }}
          password: ${{ secrets.ALIYUN_REGISTRY_PASSWORD }}

      - name: Build and Push kube-apiserver
        if: needs.build-and-push.outputs.build-apiserver == 'true'
        run: |
          echo "Building & Pushing kube-apiserver with tag ${{ env.KUBE_DOCKER_IMAGE_TAG }}"
          ./build/release-images.sh kube-apiserver
          docker push  $ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/kube-apiserver-amd64:${{ env.IMAGE_TAG }}
          echo "Image kube-apiserver pushed successfully!"


      - name: Build and Push kube-controller-manager
        if: needs.build-and-push.outputs.build-controller-manager == 'true'
        run: |
          echo "Building & Pushing kube-controller-manager with tag ${{ env.KUBE_DOCKER_IMAGE_TAG }}"
          ./build/release-images.sh kube-controller-manager
          docker push  $ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/kube-controller-manager-amd64:${{ env.IMAGE_TAG }}
          echo "Image kube-controller-manager pushed successfully!"
          
      - name: Build and Push kube-scheduler
        if: needs.build-and-push.outputs.build-scheduler == 'true'
        run: |
          echo "Building & Pushing kube-scheduler with tag ${{ env.KUBE_DOCKER_IMAGE_TAG }}"
          ./build/release-images.sh kube-scheduler
          docker push  $ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/kube-scheduler-amd64:${{ env.IMAGE_TAG }}
          echo "Image kube-scheduler pushed successfully!"

      - name: Build and Push kube-proxy
        if: needs.build-and-push.outputs.build-proxy == 'true'
        run: |
          echo "Building & Pushing kube-proxy with tag ${{ env.KUBE_DOCKER_IMAGE_TAG }}"
          ./build/release-images.sh kube-proxy
          docker push  $ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/kube-proxy-amd64:${{ env.IMAGE_TAG }}
          echo "Image kube-proxy pushed successfully!"
          
      - name: Logout from ACR
        if: always()
        run: docker logout ${{ env.ALIYUN_REGISTRY }}
